There are primarily three main categories into which an algorithm can be named in this type of classification. They are: 
 
- [[Greedy Algorithm]]: In the greedy method, at each step, a decision is made to choose the local optimum, without thinking about the future consequences. 
Example: Fractional Knapsack, Activity Selection.
- [[Divide and Conquer]]: The Divide and Conquer strategy involves dividing the problem into sub-problem, recursively solving them, and then recombining them for the final answer. Example: Merge sort, Quick-sort.
- [[Dynamic Programming]]: The approach of Dynamic programming is similar to divide and conquer. The difference is that whenever we have recursive function calls with the same result, instead of calling them again we try to store the result in a data structure in the form of a table and retrieve the results from the table. Thus, the overall time complexity is reduced. “Dynamic” means we dynamically decide, whether to call a function or retrieve values from the table. Example: 0-1 Knapsack, subset-sum problem.
- [[Linear Programming]]: In Linear Programming, there are inequalities in terms of inputs and maximizing or minimizing some linear functions of inputs. Example: Maximum flow of Directed Graph
- Reduction([[Transform and Conquer]]): In this method, we solve a difficult problem by transforming it into a known problem for which we have an optimal solution. Basically, the goal is to find a reducing algorithm whose complexity is not dominated by the resulting reduced algorithms. Example: Selection algorithm for finding the median in a list involves first sorting the list and then finding out the middle element in the sorted list. These techniques are also called transform and conquer.
- [[Backtracking]]: This technique is very useful in solving combinatoric problems that have a single unique solution. Where we have to find the correct combination of steps that lead to fulfillment of the task.  Such problems have multiple stages and there are multiple options at each stage. This approach is based on exploring each available option at every stage one-by-one. While exploring an option if a point is reached that doesn’t seem to lead to the solution, the program control backtracks one step, and starts exploring the next option. In this way, the program explores all possible course of actions and finds the route that leads to the solution.  Example: N-queen problem, maize problem.
- [[Branch and Bound]]: This technique is very useful in solving combinatoric optimization problem that have multiple solutions and we are interested in find the most optimum solution. In this approach, the entire solution space is represented in the form of a state space tree. As the program progresses each state combination is explored, and the previous solution is replaced by new one if it is not the optimal than the current solution. Example: Job sequencing, Travelling salesman problem.